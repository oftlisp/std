;; Parses a regex's string version, or one of its components, to a CST. If the
;; regex is valid, returns a list whose first item is the symbol `ok`, whose
;; second item is the parse tree, and whose third item is the remainder of the
;; input string. If the regex is not valid, returns a cons whose head is the
;; symbol `err` and whose tail is the error (which may be nil).
;;
;; TODO: Once general monads are implemented, rewrite this to use the result
;; monad.
(module std/lang/regex/parser
  parse-cst-regex)

(def special-chars (list "|" "+" "*" "?" "." "(" ")" "[" "]" "&" "^" "!" "\\"))

(defn parse-cst-literal-char (str)
  (if (empty? str)
    (err "Unexpected EOF")
    (let1 ch (head str)
      (if (contains? special-chars ch)
        (err (concat-strings "Unexpected character: `" ch "'"))
        (ok ch (tail str))))))

(defn parse-cst-special-char (str)
  (if (empty? str)
    (err "Unexpected EOF")
    (let1 ch (head str)
      (if (contains? special-chars ch)
        (ok ch (tail str))
        (err (concat-strings "Unexpected character: `" ch "'"))))))

(defn parse-cst-char-set-literal (str)
  (if (empty? str)
    (err "Unexpected EOF")
    (let1 ch (head str)
      (if (contains? (cons "-" special-chars) ch)
        (err (concat-strings "Unexpected character: `" ch "'"))
        (ok ch (tail str))))))

(defn parse-cst-char-set-special (str)
  (if (empty? str)
    (err "Unexpected EOF")
    (let1 ch (head str)
      (if (contains? (cons "-" special-chars) ch)
        (ok ch (tail str))
        (err (concat-strings "Unexpected character: `" ch "'"))))))

(defn kleene (parser str)
  (defn helper (str accum)
    (if (empty? str)
      (cons (reverse accum) "")
      (either (parser str)
        \(helper (cadr $) (cons (car $) accum))
        \(cons (reverse accum) str))))
  (helper str nil))

(defnrec
  (parse-cst-and-branch (str)
    (<$> (parse-cst-or-branch str)
      \(let1 rst (kleene parse-cst-rest-or-branches (cadr $))
        (list (cons (car $) (car rst)) (cdr rst)))))
  (parse-cst-and-branches (str)
    (<$> (parse-cst-and-branch str)
      \(let1 rst (kleene parse-cst-rest-and-branches (cadr $))
        (list (cons (car $) (car rst)) (cdr rst)))))
  (parse-cst-atom (str)
    (if (empty? str)
      (err "Unexpected EOF")
      (case (head str)
        "."  (ok 'any-char (tail str))
        "\\" (parse-cst-special-char (tail str))
        "("  (<$> (parse-cst-paren-regex (tail str))
               \(list (list 'regex (car $)) (cadr $)))
        "["  (parse-cst-char-set (tail str))
             (parse-cst-literal-char str))))
  (parse-cst-char-set (str)
    (cond
      (empty? str)
        (err "Unexpected EOF")
      (eq (head str) "^")
        (<$> (parse-cst-char-set-groups (tail str))
          \(list (list 'not (car $)) (cadr $)))
      else
        (<$> (parse-cst-char-set-groups str)
          \(list (list 'just (car $)) (cadr $)))))
  (parse-cst-char-set-char (str)
    (cond
      (empty? str)
        (err "Unexpected EOF")
      (eq (head str) "\\")
        (parse-cst-char-set-special (tail str))
      else
        (parse-cst-char-set-literal str)))
  (parse-cst-char-set-group (str)
    (>>= (parse-cst-char-set-char str)
      \(let (fst (car $))
            (str (cadr $))
        (if (or (empty? str) (neq (head str) "-"))
          (ok (list (list 'one fst) str))
          (<$> (parse-cst-char-set-char (tail str))
            \(let (snd (car $))
                  (str (cadr $))
              (list (list 'range fst snd) str)))))))
  (parse-cst-char-set-groups (str)
    (def tmp (kleene parse-cst-char-set-group str))
    (def grps (car tmp))
    (def str (cdr tmp))
    (cond
      (empty? str)
        (err "Unexpected EOF")
      (eq (head str) "]")
        (ok grps (tail str))
      else
        (err (concat-strings "Unexpected character: `" (head str) "'"))))
  (parse-cst-or-branch (str)
    (either (parse-cst-piece str)
      \(let1 rst (kleene parse-cst-piece (cadr $))
        (ok (cons (car $) (car rst)) (cdr rst)))
      \(ok nil str)))
  (parse-cst-paren-regex (str)
    (>>= (parse-cst-regex str)
      \(let (str (cadr $))
            (re  (car $))
        (if (empty? str)
          (err "Unexpected EOF")
          (let1 ch (head str)
            (if (eq ch ")")
              (ok re (tail str))
              (err (concat-strings "Unexpected character: `" ch "'"))))))))
  (parse-cst-piece (str)
    (<$> (parse-cst-atom str)
      (fn (atom)
        (either (parse-cst-qualifier (cadr atom))
          \(list (cons (car atom) (car $)) (cadr $))
          \(list (list (car atom)) (cadr atom))))))
  (parse-cst-qualifier (str)
    (if (empty? str)
      (err "Unexpected EOF")
      (let (ch (head str))
           (tl (tail str))
        (case ch
          "+" (ok '+ tl)
          "*" (ok '* tl)
          "?" (ok '? tl)
              (err (concat-strings "Unexpected character: `" ch "'"))))))
  (parse-cst-regex (str)
    (cond
      (empty? str)
        (<$> (parse-cst-and-branches str)
          \(list (list 'just (car $)) (cadr $)))
      (eq (head str) "!")
        (<$> (parse-cst-and-branches (tail str))
          \(list (list 'not (car $)) (cadr $)))
      else
        (<$> (parse-cst-and-branches str)
          \(list (list 'just (car $)) (cadr $)))))
  (parse-cst-rest-and-branches (str)
    (cond
      (empty? str)
        (err "Unexpected EOF")
      (eq (head str) "&")
        (parse-cst-and-branch (tail str))
      else
        (err (concat-strings "Unexpected character: `" (head str) "'"))))
  (parse-cst-rest-or-branches (str)
    (cond
      (empty? str)
        (err "Unexpected EOF")
      (eq (head str) "|")
        (parse-cst-or-branch (tail str))
      else
        (err (concat-strings "Unexpected character: `" (head str) "'")))))
