(module std/internal/prelude/objects
  defclass
  defmethod)

(import std/internal/prelude/constants
  else
  nil)
(import std/internal/prelude/format
  show)
(import std/internal/prelude/fp
  .
  enumerate
  filter
  group-by
  lookup
  map)
(import std/internal/prelude/logic
  and)
(import std/internal/prelude/math
  /=
  1+)
(import std/internal/prelude/print
  print
  println)
(import std/internal/prelude/quasiquote
  quasiquote)
(import std/internal/prelude/util
  caar
  cadr
  cdar
  cddr
  caddr
  cdddr
  cddar)
(import std/internal/prelude/util/macros
  ->
  cond
  todo
  unless
  when)
(import std/internal/prelude/util/pseudoprims
  append
  contains?
  length
  list
  not
  reverse)
(import std/internal/primitives
  =
  apply
  car
  cdr
  concat-strings
  cons
  cons?
  debug
  eq
  gensym
  nil?
  panic
  string<-symbol
  symbol<-string
  symbol?
  unwind-protect)

;; The class declarator. Of the form:
;;
;;   (defclass NAME
;;     DECLS...)
;;
;; Each DECL is one of:
;;
;;   (ctor ARGS BODY-EXPR...)
;;   (named-ctor NAME ARGS BODY-EXPR...)
;;   (defn NAME ARGS BODY-EXPR...)
;;   (val NAME)
;;
;; A ctor form expands to a function with the name of the class, which
;; constructs an instance of the class.
;;
;; A named-ctor is equivalent to a ctor, but the name of the constructor is
;; `CLASS-NAME`-`NAME`.
;;
;; A defn form causes a function whose name is of the form `CLASS-NAME`.`NAME`
;; to be defined. This function has all the class variables defined by val
;; forms to be in scope.
;;
;; A val form defines a class variable.
;;
;; TODO: Should `this` exist?
;; TODO: Automatic getters/setters?
;; TODO: This needs more safety checks.
(defmacro defclass (class-name ... decls)
  ; Check the name.
  (unless (symbol? class-name)
    (panic "Invalid defclass name"))

  ; Group the decls together.
  (def decls (group-by car decls))
  (unless (cons? decls)
    (panic (concat-strings
      "Invalid defclass "
      (string<-symbol class-name)
      ": No body")))

  ; Check that the decls are all of known types.
  (def unknown-decl-types (filter
    (fn (x) (not (contains? x '(ctor defn named-ctor val))))
    (map car decls)))
  (unless (nil? unknown-decl-types)
    (panic (concat-strings
      "Invalid defclass "
      (string<-symbol class-name)
      ": Unexpected form types: "
      (show unknown-decl-types))))

  ; Check for != 1 unnamed constructors.
  (when (/= (length (lookup 'ctor decls)) 1)
    (panic (concat-strings
      "Invalid defclass "
      (string<-symbol class-name)
      ": Must have exactly one unnamed constructor")))

  ; Process the constructors.
  (defn build-ctor (form)
    (def name (if (nil? (car form))
      class-name
      (symbol<-string
        (concat-strings
          (string<-symbol class-name)
          "-"
          (string<-symbol (car form))))))
    (def args (cadr form))
    (def body (cddr form))
    `(,name ,args
      (cons ',class-name
        (progn ,@body))))
  (def ctors (cons
    (build-ctor (cons nil (cdar (lookup 'ctor decls))))
    (map (. build-ctor cdr) (lookup 'named-ctor decls))))

  ; Add a function to check for class membership.
  (def is-class?-name (symbol<-string
    (concat-strings (string<-symbol class-name) "?")))
  (def is-class? (progn
    `(,is-class?-name (obj)
      (and
        (cons? obj)
        (eq (car obj) ',class-name)))))

  ; Process the member functions.
  (def member-prelude (progn
    (defn loop (n l a)
      (if (nil? l)
        (reverse a)
        (loop (1+ n) (cdr l)
          (cons `(def ,(car l) (nth ,n this)) a))))
    (def vals (map cadr (lookup 'val decls)))
    (cons
      `(assert (,is-class?-name this))
      (loop 1 vals nil))))
  (defn build-member-defn (form)
    (def name (symbol<-string
      (concat-strings
        (string<-symbol class-name)
        "."
        (string<-symbol (car form)))))
    (def args (cadr form))
    (def body (cddr form))
    `(,name ,(cons 'this args)
      ,@member-prelude
      ,@body))
  (def defns (-> decls
    (lookup 'defn)
    (map cdr)
    (map build-member-defn)))

  ; Build the final expression.
  `(defnrec
    ,@ctors
    ,@defns
    ,is-class?))

;; Defines a method.
(defmacro defmethod (name)
  (def obj (gensym))
  (def args (gensym))
  `(defn ,name (,obj ... ,args)
    (apply (get (car ,obj) ',name) ,args)))
