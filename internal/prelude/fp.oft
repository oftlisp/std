;; Functional programming primitives.
(module std/internal/prelude/fp
  .
  all
  any
  defcurried
  enumerate
  filter
  flat-map
  foldl
  foldr
  each
  group-by
  lookup
  lookup-all
  lookup-all-by
  lookup-by
  map
  skip
  sort
  sort-by
  take
  uniq
  unique
  zip)

(import std/internal/prelude/fp/list
  list.all
  list.any
  list.enumerate
  list.filter
  list.flat-map
  list.foldl
  list.foldr
  list.each
  list.group-by
  list.lookup
  list.lookup-all
  list.lookup-all-by
  list.lookup-by
  list.map
  list.skip
  list.sort
  list.sort-by
  list.take
  list.uniq
  list.zip)
(import std/internal/prelude/fp/vector
  vector.all
  vector.any
  vector.enumerate
  vector.filter
  vector.flat-map
  vector.foldl
  vector.foldr
  vector.each
  vector.group-by
  vector.lookup
  vector.lookup-all
  vector.lookup-all-by
  vector.lookup-by
  vector.map
  vector.skip
  vector.sort
  vector.sort-by
  vector.take
  vector.uniq
  vector.zip)
(import std/internal/prelude/util
  reverse)
(import std/internal/prelude/util/macros
  when)
(import std/internal/prelude/util/pseudoprims
  last
  list)
(import std/internal/primitives
  car
  cdr
  concat-strings
  cons
  nil?
  panic
  string<-symbol
  symbol<-string
  vector?)

;; Function composition.
(defn . (... l)
  (def funcs (reverse l))
  (defn loop (x l)
    (if (nil? l)
      x
      (loop ((car l) x) (cdr l))))
  (fn (x) (loop x funcs)))

(defmacro defcurried (name args body-car ... body-cdr)
  (when (nil? args)
    (panic "Cannot defcurried a function that takes no arguments"))

  (defn helper (args body)
    (cons 'fn
      (cons (list (car args))
        (if (nil? (cdr args))
          body
          (list (helper (cdr args) body))))))
  (list 'def name (helper args (cons body-car body-cdr))))

(defmacro deffpgeneric (name args)
  (def list-op (symbol<-string
    (concat-strings "list." (string<-symbol name))))
  (def vector-op (symbol<-string
    (concat-strings "vector." (string<-symbol name))))
  (list 'defn name args
    (list 'if (list 'vector? (car args))
      (cons vector-op args)
      (cons list-op args))))

(deffpgeneric all (l f))
(deffpgeneric any (l f))
(deffpgeneric each (l f))
(deffpgeneric enumerate (l))
(deffpgeneric filter (l f))
(deffpgeneric flat-map (l f))
(deffpgeneric foldl (xs f x))
(deffpgeneric foldr (xs f x))
(deffpgeneric group-by (l f))
(deffpgeneric lookup (xs x))
(deffpgeneric lookup-all (xs x))
(deffpgeneric lookup-all-by (xs f x))
(deffpgeneric lookup-by (xs f x))
(deffpgeneric map (l f))
(deffpgeneric skip (l n))
(deffpgeneric sort (l))
(deffpgeneric sort-by (l f))
(deffpgeneric take (l n))
(deffpgeneric uniq (l))
(defn unique (l) (uniq (sort l)))
(deffpgeneric zip (l r))
