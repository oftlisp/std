(module std/args
  [make-arg-parser parse-args usage]
  "Functions for creating and running argument parsers.")

; An argument parser spec is a tuple:
;
;   (APP-NAME USAGE ARG-SPEC SHORT-FLAGS LONG-FLAGS SHORT-OPTS LONG-OPTS)
;
; APP-NAME is a string.
; USAGE is a string.
; ARG-SPEC is a (possibly improper) list of symbols.
; SHORT-FLAGS is an assoc from symbols with one character to symbols.
; LONG-FLAGS is an assoc from symbols to symbols.
; SHORT-OPTS is an assoc from symbols with one character to symbols.
; LONG-OPTS is an assoc from symbols to symbols.

(defn map-nth (f n t)
  "Maps the nth item of the tuple t with the function f."
  (append (take n t)
    (cons (f (nth n t))
      (skip (1+ n) t))))

(defn-> sym-skip (n)
  "Removes the first n characters of the given symbol."
  symbol->string
  (skip n)
  string->symbol)

(defn short? (sym)
  "Checks if a symbol is a short option."
  (def str (symbol->string sym))
  (and (> (length str) 1)
       (equals (slice 0 1 str) "-")
       (not (equals (slice 0 2 str) "--"))))
(defn long? (sym)
  "Checks if a symbol is a long option."
  (def str (symbol->string sym))
  (and (> (length str) 2) (equals (slice 0 2 str) "--")))

(defn arg-parser (app-name arg-spec opt-specs)
  "Creates an argument parser that can be passed into parse-args or usage.

   ```
   (arg-parser 'my-cool-app '(foo | bar)
     '((option output -o --output)
       (flag verbose -v)
       (flag help -h --help)))
   ```"

  (def app-name (cond
    (symbol? app-name) (symbol->string app-name)
    (string? app-name) app-name
                       (panic (cons 'invalid-app-name app-name))))

  (defn add-flag (parser-spec flag-spec)
    (def name (car flag-spec))
    (defn helper (parser-spec flag)
      (cond
        (short? flag) (map-nth \(cons (pair (sym-skip 1 flag) name) $) 1 parser-spec)
        (long? flag)  (map-nth \(cons (pair (sym-skip 2 flag) name) $) 2 parser-spec)
                      (panic `(invalid-option-flag ,flag))))
    (foldl helper parser-spec (cdr flag-spec)))

  (defn add-option (parser-spec option-spec)
    (def name (car option-spec))
    (defn helper (parser-spec flag)
      (cond
        (short? flag) (map-nth \(cons (pair (sym-skip 1 flag) name) $) 3 parser-spec)
        (long? flag)  (map-nth \(cons (pair (sym-skip 2 flag) name) $) 4 parser-spec)
                      (panic `(invalid-option-flag ,flag))))
    (foldl helper parser-spec (cdr option-spec)))

  (defn add-spec (parser-spec opt-spec)
    (cond
      (shl? 'flag opt-spec)   (add-flag   parser-spec (cdr opt-spec))
      (shl? 'option opt-spec) (add-option parser-spec (cdr opt-spec))
                              (panic `(invalid-parser-opt-spec ,opt-spec))))

  (defn flag-usage (flag)
    (string-join ", " (map symbol->string (cdr flag))))
  (defn option-usage (option)
    (string-join ", " (map
      \(append (symbol->string $) " " (symbol->string (car option)))
      (cdr option))))
  (defn spec-usage (opt-spec)
    (cond
      (shl? 'flag opt-spec)   (flag-usage   (cdr opt-spec))
      (shl? 'option opt-spec) (option-usage (cdr opt-spec))
                              (panic `(invalid-parser-opt-spec ,opt-spec))))
  (defn make-usage (opt-specs)
    (def args (string-join "" (map \(append " " (symbol->string $)) arg-spec)))
    (def opts (append "\n" (string-join "\n" (map spec-usage opt-specs)) "\n"))
    (append "USAGE: " app-name " [OPTIONS]" args "\n" opts))

  (cons app-name (cons (make-usage opt-specs)
    (foldl add-spec (list arg-spec nil nil nil nil) opt-specs))))

(defmacro make-arg-parser (app-name arg-spec | opt-specs)
  "Creates an argument parser that can be passed into parse-args or usage.

   ```
   (make-arg-parser my-cool-app (foo | bar) ; one foo arg, zero-infinity bar args
     (option output -o --output)            ; an option, -o or --output, named output
     (flag verbose -v)                      ; a flag, -v, named verbose
     (flag help -h --help))                 ; a flag, -h or --help, named help
   (make-arg-parser other-app (baz? quux?)) ; two optional args, baz and quux
   (make-arg-parser third-app ()            ; no args
     (flag quiet -q))                       ; a flag, -q, named quiet
   ```"

  `(quote ,(arg-parser app-name arg-spec opt-specs)))

(defn parse-args (args spec)
  "Parses arguments with the argument parser. Returns a pair (FLAGS OPTS), where FLAGS is a list of
   the symbols associated with flags and OPTS is an assoc from the names of arguments and options
   to the values, which will be strings with the exception of the rest argument, which (if present)
   will be a list."
  (def `(,app-name ,usage ,arg-spec ,short-flags ,long-flags ,short-opts ,long-opts) spec)
  (defn helper (args state)
    (def (pair flags opts) state)
    (if (nil? args)
      state
      (let ((arg  (car args))
            (args (cdr args)))
        ; arg ~ /-([^-]*)([^-])/ => (map as-short-flag $1) (as-short-option $2)
        ; arg ~ /--([^-])/ => (as-long $1)
        (cond
          (short? arg) (progn
                         (def s (symbol->string arg))
                         (def flags (map string->symbol (as-chars (slice 1 (1- (length s)) s))))
                         (def option (string->symbol (last s)))
                         (todo 'short s option flags))
          (long? arg)  (progn
                         (def long (sym-skip 2 arg))
                         (todo 'long long))
        ))))
  (helper args (pair nil nil)))

(defn usage (spec)
  "Returns a usage message for the given argument parser."
  (nth 1 spec))

(defn usage-and-exit (spec)
  "Prints a usage message for the given argument parser, then exits with status code 1."
  (println (usage spec))
  (panic '(exit | 1)))
