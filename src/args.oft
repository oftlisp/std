(module std/args
  [make-arg-parser parse-args usage]
  "Functions for creating and running argument parsers.")

; An argument parser spec is a tuple (APP-NAME ARG-SPEC SHORT-FLAGS LONG-FLAGS SHORT-OPTS LONG-OPTS).
;
; APP-NAME is a string.
; ARG-SPEC is a (possibly improper) list of symbols.
; SHORT-FLAGS is an assoc from symbols with one character to symbols.
; LONG-FLAGS is an assoc from symbols to symbols.
; SHORT-OPTS is an assoc from symbols with one character to symbols.
; LONG-OPTS is an assoc from symbols to symbols.

(defn map-nth (f n t)
  "Maps the nth item of the tuple t with the function f."
  (append (take n t)
    (cons (f (nth n t))
      (skip (1+ n) t))))

(defn-> sym-skip (n)
  "Removes the first n characters of the given symbol."
  symbol->string
  (skip n)
  string->symbol)

(defn short? (sym)
  "Checks if a symbol is a short option."
  (def str (symbol->string sym))
  (and (> (length str) 1)
       (equals (slice 0 1 str) "-")
       (not (equals (slice 0 2 str) "--"))))
(defn long? (sym)
  "Checks if a symbol is a long option."
  (def str (symbol->string sym))
  (and (> (length str) 2) (equals (slice 0 2 str) "--")))

(defmacro make-arg-parser (app-name arg-spec | opt-specs)
  "Creates an argument parser that can be passed into parse-args or usage.

   ```
   (make-arg-parser my-cool-app (foo | bar) ; one foo arg, zero-infinity bar args
     (option output -o --output)            ; an option, -o or --output, named output
     (flag verbose -v)                      ; a flag, -v, named verbose
     (flag help -h --help))                 ; a flag, -h or --help, named help
   (make-arg-parser other-app (baz? quux?)) ; two optional args, baz and quux
   (make-arg-parser third-app ()            ; no args
     (flag quiet -q))                       ; a flag, -q, named quiet
   ```"

  (def app-name (cond
    (symbol? app-name) (symbol->string app-name)
    (string? app-name) app-name
                       (panic (cons 'invalid-app-name app-name))))

  (defn add-flag (parser-spec flag-spec)
    (def name (car option-spec))
    (defn helper (parser-spec flag)
      (cond
        (short? flag) (map-nth \(cons (pair (sym-skip 1 flag) name) $) 1 parser-spec)
        (long? flag)  (map-nth \(cons (pair (sym-skip 2 flag) name) $) 2 parser-spec)
                      (panic `(invalid-option-flag ,flag))))
    (foldl helper parser-spec (cdr option-spec)))
  (defn add-option (parser-spec option-spec)
    (def name (car option-spec))
    (defn helper (parser-spec flag)
      (cond
        (short? flag) (map-nth \(cons (pair (sym-skip 1 flag) name) $) 3 parser-spec)
        (long? flag)  (map-nth \(cons (pair (sym-skip 2 flag) name) $) 4 parser-spec)
                      (panic `(invalid-option-flag ,flag))))
    (foldl helper parser-spec (cdr option-spec)))
  (defn add-spec (parser-spec opt-spec)
    (cond
      (shl? 'flag opt-spec)   (add-flag   parser-spec (cdr opt-spec))
      (shl? 'option opt-spec) (add-option parser-spec (cdr opt-spec))
                              (panic `(invalid-parser-opt-spec ,opt-spec))))

  `(quote ,(cons app-name (foldl add-spec (list arg-spec nil nil nil nil) opt-specs))))

(defn parse-args (args spec)
  "Parses arguments with the argument parser."
  (def `(,app-name ,arg-spec ,short-flags ,long-flags ,short-opts ,long-opts) spec)
  (todo parse-args))

(defn usage (spec)
  "Returns a usage message for the given argument parser."
  (def `(,app-name ,arg-spec ,short-flags ,long-flags ,short-opts ,long-opts) spec)
  (def args (string-join "" (map \(append " " (symbol->string $)) arg-spec)))
  (def flags (string-join "" (sort (append
    (map (fn ((pair flag name)) (append "-" (symbol->string flag) " " (symbol->string name))) short-flags)
    (map (fn ((pair flag name)) (append "--" (symbol->string flag) " " (symbol->string name))) long-flags)))))
  (append "USAGE: " app-name " [OPTIONS]" args "\n" flags "\n"))
