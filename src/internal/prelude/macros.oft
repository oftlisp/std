(module std/internal/prelude/macros
  [-> afn and case cond def defmacro defmacro* defn defn-> fn let let1 list matches? or
   quasiquote todo unless when]
  no-prelude)

(import std/internal/prelude/conversions
  [string->symbol symbol->string])
(import std/internal/prelude/intrinsics
  [car cdr cons cons? eq gensym nil nil? panic string? symbol? true vector?])
(import std/internal/prelude/list
  [list-map])
(import std/internal/prelude/string
  [string-append])
(import std/internal/prelude/util
  [debug-trace shl?])

; TODO: Should this use the std/prelude versions instead?
(intrinsics:defmacro list form
  (intrinsics:defn helper (form)
    (if (nil? form)
      'std/internal/prelude/intrinsics:nil
      (cons 'std/internal/prelude/intrinsics:cons
        (cons (car form)
          (cons (helper (cdr form))
            nil)))))
  (cons (helper form) nil))

(intrinsics:defmacro quasiquote form
  ; (a ,b ,@c ,d) -> (append (list 'a) (append (list b) (append c (append (list d) nil))))
  ; (,a ,b | ,c) -> (append (list a) (append (list b) (list c)))
  (intrinsics:defn qq (form)
    (if (shl? 'unquote form)
      (car (cdr form))
      (if (shl? 'unquote-splicing form)
        (panic ",@ not supported at the top level of a quasiquote")
        (if (cons? form)
          (list 'std/internal/prelude/list:list-append
            (qq-list-inner (car form))
            (qq (cdr form)))
          (if (vector? form)
            (vector-map qq-vector-inner form)
            (cons 'quote (cons form nil)))))))
  (intrinsics:defn qq-list-inner (form)
    (if (shl? 'unquote form)
      (list 'list (car (cdr form)))
      (if (shl? 'unquote-splicing form)
        (car (cdr form))
        (list 'list (qq form)))))
  (intrinsics:defn qq-vector-inner (form)
    (if (shl? 'unquote form)
      (car (cdr form))
      (if (shl? 'unquote-splicing form)
        (panic ",@ not yet supported in vectors")
        (qq form))))
  (cons (qq (car form)) nil))

(intrinsics:defn defmacro-helper (form func)
  (intrinsics:def macro-name (car form))
  (intrinsics:def macro-body (cdr (cdr form)))
  ; defmacro parameters are a (possibly improper) list containing only symbols. This list is
  ; matched against the list of arguments. For example, (a b | c) matches against (1 2 3 4) as
  ; a = 1, b = 2, c = (3 4). Note that a symbol is itself an improper list containing only symbols.
  ; As such, foo matches against (1 2 3 4) as foo = (1 2 3 4).
  (intrinsics:defn helper (args params)
    (if (cons? params)
      `((intrinsics:def ,(car params) (car ,args))
        ,@(helper `(cdr ,args) (cdr params)))
      (if (nil? params)
        `((if (nil? ,args)
            '()
            (panic ,(string-append "invalid arguments to macro " (symbol->string macro-name))))
          ,@macro-body)
        (if (symbol? params)
          `((intrinsics:def ,params ,args)
            ,@macro-body)
          (panic (cons 'invalid-defmacro-params params))))))
  (intrinsics:def param-name (gensym))
  (func macro-name param-name (helper param-name (car (cdr form)))))

(intrinsics:defmacro defmacro form
  (list (defmacro-helper form
    (intrinsics:fn (macro-name param-name macro-body)
      `(intrinsics:defmacro ,macro-name ,param-name
        (std/internal/prelude/intrinsics:cons
          (progn ,@macro-body)
          std/internal/prelude/intrinsics:nil))))))

(intrinsics:defmacro defmacro* form
  (list (defmacro-helper form
    (intrinsics:fn (macro-name param-name macro-body)
      `(intrinsics:defmacro ,macro-name ,param-name
        (progn ,@macro-body))))))

(defmacro cond cases
  (if (nil? cases)
    'nil
    (if (nil? (cdr cases))
      (car cases)
      `(if ,(car cases)
        ,(car (cdr cases))
        (cond ,@(cdr (cdr cases)))))))

(intrinsics:defn pat-bind-helper (pat expr-name)
  (cond
    (eq pat '_)   nil
    (symbol? pat) (list `(intrinsics:def ,pat ,expr-name))
    (cons? pat)   (progn
                    (intrinsics:def name (string->symbol (string-append "pat-"
                      (string-append (symbol->string (car pat)) "-bind"))))
                    `(,name ,(cdr pat) ,expr-name))
                  (panic (cons 'invalid-pattern pat))))

(intrinsics:defn pat-matches?-helper (pat expr-name)
  (cond
    (eq pat '_)   'true
    (symbol? pat) 'true
    (cons? pat)   (progn
                    (intrinsics:def name (string->symbol (string-append "pat-"
                      (string-append (symbol->string (car pat)) "-matches?"))))
                    `(,name ,(cdr pat) ,expr-name))
                  (panic (cons 'invalid-pattern pat))))

(defmacro if-let (pat expr t e)
  (intrinsics:def expr-name (gensym))
  (intrinsics:def matches? (pat-matches?-helper pat expr-name))
  (intrinsics:def bind (pat-bind-helper pat expr-name))
  `(progn
    (intrinsics:def ,expr-name ,expr)
    (if ,(pat-matches?-helper pat expr-name) (progn ,@(pat-bind-helper pat expr-name) ,t) ,e)))

(defmacro matches? (pat expr)
  `(if-let ,pat ,expr true false))

(defmacro case (expr | clauses)
  (intrinsics:def expr-name (gensym))
  (intrinsics:defn helper (clauses)
    (cond
      (nil? clauses)       `(panic (cons 'no-case-matches ,expr-name))
      (nil? (cdr clauses)) (car clauses)
                           (progn
                             (intrinsics:def pat (car clauses))
                             (intrinsics:def expr (car (cdr clauses)))
                             (intrinsics:def rest (cdr (cdr clauses)))
                             (intrinsics:def matches? (pat-matches?-helper pat expr-name))
                             (intrinsics:def bind (pat-bind-helper pat expr-name))
                             `(if ,matches?
                               (progn ,@bind ,expr)
                               ,(helper rest)))))
  `(progn
    (intrinsics:def ,expr-name ,expr)
    ,(helper clauses)))

(defmacro* def (pat expr)
  (cond
    (eq pat '_)   (list `(intrinsics:def ,(gensym) ,expr))
    (symbol? pat) (list `(intrinsics:def ,pat ,expr))
                  (progn
                    (intrinsics:def expr-name (gensym))
                    (intrinsics:def matches? (pat-matches?-helper pat expr-name))
                    (intrinsics:def bind (pat-bind-helper pat expr-name))
                    (list
                      `(intrinsics:def ,expr-name ,expr)
                      `(if ,matches?
                        std/internal/prelude/intrinsics:nil
                        (std/internal/prelude/intrinsics:panic
                          (std/internal/prelude/intrinsics:cons 'def-match-failed ,expr-name)))
                      bind))))

(defmacro defn (name args | body)
  (intrinsics:def args (list-map \(cons $ (gensym)) args))
  (intrinsics:def arg-binds (list-map \`(def ,(car $) ,(cdr $)) args))
  `(intrinsics:defn ,name ,(list-map cdr args)
    (progn ,@arg-binds ,@body)))

(defmacro fn (args | body)
  (intrinsics:def args (list-map \(cons $ (gensym)) args))
  (intrinsics:def arg-binds (list-map \`(def ,(car $) ,(cdr $)) args))
  `(intrinsics:defn ,(list-map cdr args)
    (progn ,@arg-binds ,@body)))

(defmacro afn (args | body)
  `(progn (defn $ ,args ,@body) $))

(defmacro and form
  (if (nil? form)
    'true
    `(if ,(car form)
      (and ,@(cdr form))
      false)))

(defmacro or form
  (if (nil? form)
    'false
    `(if ,(car form)
      true
      (or ,@(cdr form)))))

(defmacro -> (var | funcs)
  (defn helper (funcs expr)
    (cond
      (nil? funcs)          expr
      (symbol? (car funcs)) (helper (cdr funcs) `(,(car funcs) ,expr))
                            (helper (cdr funcs) `(,@(car funcs) ,expr))))
  (helper funcs var))

(defmacro defn-> (name args | body)
  (def main-arg (gensym))
  (def body (if (and (cons? body) (string? (car body))) (cdr body) body))
  `(defn ,name (,@args ,main-arg)
    (-> ,main-arg ,@body)))

(defmacro let (bindings | body)
  (defn make-binding-def (binding)
    `(def ,(car binding) (progn ,@(cdr binding))))
  `(progn ,@(list-map make-binding-def bindings) ,@body))

(defmacro let1 (name expr | body)
  `(progn (def ,name ,expr) ,@body))

(defmacro todo form
  `(panic (list 'todo ,@form)))

(defmacro unless (c | b)
  `(if ,c std/internal/prelude/intrinsics:nil (progn ,@b)))
(defmacro when (c | b)
  `(if ,c (progn ,@b) std/internal/prelude/intrinsics:nil))
