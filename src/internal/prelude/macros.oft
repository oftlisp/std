(module std/internal/prelude/macros
  [-> afn and case cond def defmacro defn defn* defn-> fn let let1 list or pat-matches? quasiquote
   todo unless when]
  no-prelude)

(import std/internal/prelude/conversions
  [string->symbol symbol->string])
(import std/internal/prelude/intrinsics
  [car cdr cons cons? eq gensym nil nil? panic string? symbol? true vector?])
(import std/internal/prelude/list
  [list-flat-map list-map])
(import std/internal/prelude/string
  [string-append])
(import std/internal/prelude/util
  [debug-trace shl?])

; TODO: Should this use the std/prelude versions instead?
(intrinsics:defmacro list form
  (intrinsics:defn helper (form)
    (if (nil? form)
      'std/internal/prelude/intrinsics:nil
      (cons 'std/internal/prelude/intrinsics:cons
        (cons (car form)
          (cons (helper (cdr form))
            nil)))))
  (helper form))

(intrinsics:defmacro quasiquote form
  ; (a ,b ,@c ,d) -> (append (list 'a) (append (list b) (append c (append (list d) nil))))
  ; (,a ,b | ,c) -> (append (list a) (append (list b) (list c)))
  (intrinsics:defn qq (form)
    (if (shl? 'unquote form)
      (car (cdr form))
      (if (shl? 'unquote-splicing form)
        (panic ",@ not supported at the top level of a quasiquote")
        (if (cons? form)
          (list 'std/internal/prelude/list:list-append
            (qq-list-inner (car form))
            (qq (cdr form)))
          (if (vector? form)
            (vector-map qq-vector-inner form)
            (cons 'quote (cons form nil)))))))
  (intrinsics:defn qq-list-inner (form)
    (if (shl? 'unquote form)
      (list 'list (car (cdr form)))
      (if (shl? 'unquote-splicing form)
        (car (cdr form))
        (list 'list (qq form)))))
  (intrinsics:defn qq-vector-inner (form)
    (if (shl? 'unquote form)
      (car (cdr form))
      (if (shl? 'unquote-splicing form)
        (panic ",@ not yet supported in vectors")
        (qq form))))
  (qq (car form)))

(intrinsics:defmacro defmacro form
  (intrinsics:def macro-name (car form))
  (intrinsics:def macro-body (cdr (cdr form)))
  ; defmacro parameters are a (possibly improper) list containing only symbols. This list is
  ; matched against the list of arguments. For example, (a b | c) matches against (1 2 3 4) as
  ; a = 1, b = 2, c = (3 4). Note that a symbol is itself an improper list containing only symbols.
  ; As such, foo matches against (1 2 3 4) as foo = (1 2 3 4).
  (intrinsics:defn helper (args params)
    (if (cons? params)
      `((intrinsics:def ,(car params) (car ,args))
        ,@(helper `(cdr ,args) (cdr params)))
      (if (nil? params)
        `((if (nil? ,args)
            '()
            (panic ,(string-append "invalid arguments to macro " (symbol->string macro-name))))
          ,@macro-body)
        (if (symbol? params)
          `((intrinsics:def ,params ,args)
            ,@macro-body)
          (panic (cons invalid-defmacro-params params))))))
  (intrinsics:def param-name (gensym))
  `(intrinsics:defmacro ,macro-name ,param-name
    (progn ,@(helper param-name (car (cdr form))))))

(defmacro cond cases
  (if (nil? cases)
    'nil
    (if (nil? (cdr cases))
      (car cases)
      `(if ,(car cases)
        ,(car (cdr cases))
        (cond ,@(cdr (cdr cases)))))))

(defmacro pat-matches? (pat expr)
  (cond
    (eq pat '_)   'true
    (symbol? pat) 'true
    (cons? pat)   (progn
                    (intrinsics:def matches? (string->symbol (string-append "pat-"
                      (string-append (symbol->string (car pat)) "-matches?"))))
                    (intrinsics:def name (gensym))
                    `(progn
                      (intrinsics:def ,name ,expr)
                      (,matches? ,(cdr pat) ,name)))))

(defmacro if-let (pat value t e)
  ; TODO: Use pat-matches?
  (intrinsics:def value-name (gensym))
  (intrinsics:def body (cond
    (eq pat '_)   `t
    (symbol? pat) `(progn (intrinsics:def ,pat ,value-name) ,t)
    (cons? pat)   (progn
                    (intrinsics:def bind (string->symbol (string-append "pat-"
                      (string-append (symbol->string (car pat)) "-bind"))))
                    (intrinsics:def matches? (string->symbol (string-append "pat-"
                      (string-append (symbol->string (car pat)) "-matches?"))))
                    `(if (,matches? ,(cdr pat) ,value-name)
                      (,bind ,(cdr pat) ,value-name ,t)
                      ,e))
                  (panic (cons 'invalid-pattern pat))))
  `(progn (intrinsics:def ,value-name ,value) ,body))

(defmacro case (value | clauses)
  ; TODO: Use pat-matches?, if-let
  (intrinsics:def value-name (gensym))
  (intrinsics:defn helper (clauses)
    (if (nil? clauses)
      `(panic (cons 'no-case-matches ,value-name))
      (if (nil? (cdr clauses))
        (car clauses)
        (progn
          (intrinsics:def pat (car clauses))
          (intrinsics:def expr (car (cdr clauses)))
          (intrinsics:def rest (cdr (cdr clauses)))
          (cond
            (eq pat '_)   expr
            (symbol? pat) `(progn (intrinsics:def ,pat ,value-name) ,expr)
            (cons? pat)   (progn
                            (intrinsics:def bind (string->symbol (string-append "pat-"
                              (string-append (symbol->string (car pat)) "-bind"))))
                            (intrinsics:def matches? (string->symbol (string-append "pat-"
                              (string-append (symbol->string (car pat)) "-matches?"))))
                            `(if (,matches? ,(cdr pat) ,value-name)
                              (,bind ,(cdr pat) ,value-name ,expr)
                              ,(helper rest)))
                          (panic (cons 'invalid-pattern pat)))))))
  `(progn
    (intrinsics:def ,value-name ,value)
    ,(helper clauses)))

(defmacro def (pat expr)
  `(intrinsics:def ,pat ,expr))

(defmacro defn (name args | body)
  `(intrinsics:defn ,name ,args (progn ,@body)))

(defmacro fn (args | body)
  `(intrinsics:fn ,args (progn ,@body)))

(defmacro afn (args | body)
  `(progn (defn $ ,args ,@body) $))

(defmacro and form
  (if (nil? form)
    'true
    `(if ,(car form)
      (and ,@(cdr form))
      false)))

(defmacro or form
  (if (nil? form)
    'false
    `(if ,(car form)
      true
      (or ,@(cdr form)))))

(defmacro -> (var | funcs)
  (defn helper (funcs expr)
    (cond
      (nil? funcs)          expr
      (symbol? (car funcs)) (helper (cdr funcs) `(,(car funcs) ,expr))
                            (helper (cdr funcs) `(,@(car funcs) ,expr))))
  (helper funcs var))

(defmacro defn-> (name args | body)
  (def main-arg (gensym))
  (def body (if (and (cons? body) (string? (car body))) (cdr body) body))
  `(defn ,name (,@args ,main-arg)
    (-> ,main-arg ,@body)))

(defmacro let (bindings | body)
  (defn make-binding-def (binding)
    `(def ,(car binding) (progn ,@(cdr binding))))
  `(progn ,@(list-map make-binding-def bindings) ,@body))

(defmacro let1 (name expr | body)
  `(progn (def ,name ,expr) ,@body))

(defmacro todo form
  `(panic (list 'todo ,@form)))

(defmacro defn* form
  (todo 'defn*))

(defmacro unless (c | b)
  `(if ,c std/internal/prelude/intrinsics:nil (progn ,@b)))
(defmacro when (c | b)
  `(if ,c (progn ,@b) std/internal/prelude/intrinsics:nil))
