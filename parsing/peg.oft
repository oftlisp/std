;; A parser macro for parsing with parsing expression grammars. If you're
;; trying to parse a programming language, this is the module for you.
(module std/parsing/peg
  defsyntax-peg)

(import std/parsing/peg/internals
  assert-expr-well-formed
  assert-production-well-formed
  extract-terminals)

;; Defines a parsing function. Takes the name of the function and a list of
;; productions. A parsing function returns a result. If the result is ok, it
;; contains the parse tree and the remainder of unparsed input. If the result
;; is err, it contains the parse error.
;;
;; Productions are specified as:
;;
;;   PRODUCTION ::= (PRODUCTION-NAME EXPR...)
;;   EXPR ::= . | PRODUCTION-NAME | LITERAL-STRING | (regex REGEX-STRING)
;;         |  (choose EXPR...) | [EXPR...]
;;         |  (* EXPR) | (+ EXPR) | (? EXPR)
;;         |  (and EXPR) | (not EXPR)
;;   PRODUCTION-NAME ::= any symbol other than .
;;   LITERAL-STRING ::= any string
;;   REGEX-STRING ::= the string representation of a regex
;;
;; If two or more productions share the same name, an implicit choose between
;; the different productions is inserted, with the (lexically) first one coming
;; first. There must be at least one production named root; this is where
;; parsing begins.
;;
;; For example, the PEG:
;;
;;   # Hierarchical syntax
;;   Grammar    <- Spacing Definition+ EndOfFile
;;   Definition <- Identifier LEFTARROW Expression
;;
;;   Expression <- Sequence (SLASH Sequence)*
;;   Sequence   <- Prefix*
;;   Prefix     <- (AND / NOT)? Suffix
;;   Suffix     <- Primary (QUESTION / STAR / PLUS)?
;;   Primary    <- Identifier !LEFTARROW
;;               / OPEN Expression CLOSE
;;               / Literal / Class / DOT
;;
;;   # Lexical syntax
;;   Identifier <- IdentStart IdentCont* Spacing
;;   IdentStart <- [a-zA-Z_]
;;   IdentCont  <- IdentStart / [0-9]
;;
;;   Literal    <- ['] (!['] Char)* ['] Spacing
;;               / ["] (!["] Char)* ["] Spacing
;;   Class      <- '[' (!']' Range)* ']' Spacing
;;   Range      <- Char '-' Char / Char
;;   Char       <- '\\' [nrt'"\[\]\\]
;;               / '\\' [0-2][0-7][0-7]
;;               / '\\' [0-7][0-7]?
;;               / !'\\' .
;;
;;   LEFTARROW  <- '<-' Spacing
;;   SLASH      <- '/' Spacing
;;   AND        <- '&' Spacing
;;   NOT        <- '!' Spacing
;;   QUESTION   <- '?' Spacing
;;   STAR       <- '*' Spacing
;;   PLUS       <- '+' Spacing
;;   OPEN       <- '(' Spacing
;;   CLOSE      <- ')' Spacing
;;   DOT        <- '.' Spacing
;;
;;   Spacing    <- (Space / Comment)*
;;   Comment    <- '#' (!EndOfLine .)* EndOfLine
;;   Space      <- ' ' / '\t' / EndOfLine
;;   EndOfLine  <- '\r\n' / '\n' / '\r'
;;   EndOfFile  <- !.
;;
;; is parsed by the parser resulting from:
;;
;;   (defsyntax-peg parse-peg
;;     ; Hierarchical syntax
;;     (root       spacing (+ definition) end-of-file)
;;     (definition identifier LEFT-ARROW expression)
;;
;;     (expression sequence (* [SLASH sequence]))
;;     (sequence   (* prefix))
;;     (prefix     (? (choose AND NOT)) suffix)
;;     (suffix     primary (? (choose QUESTION STAR PLUS)))
;;     (primary    identifier (not LEFT-ARROW))
;;     (primary    OPEN expression CLOSE)
;;     (primary    (choose literal class dot))
;;
;;     ; Lexical syntax
;;     (identifier  ident-start (* ident-cont) spacing)
;;     (ident-start (regex "[a-zA-Z_"))
;;     (ident-cont  (choose ident-start (regex "[0-9]")))
;;
;;     (literal "'" (* [(not "'") char]) "'" spacing])
;;     (literal "\"" (* [(not "\"") char]) "\"" spacing)
;;     (class   "[" (* (not "]") range) "]" spacing)
;;     (range   char "-" char)
;;     (range   char)
;;     (char    "\\" (regex "[nrt'\"\\[\\]\\\\]"))
;;     (char    "\\" (regex "[0-2][0-7][0-7]"))
;;     (char    "\\" (regex "[0-7][0-7]?"))
;;     (char    (not "\\") .)
;;
;;     (LEFT-ARROW "<-" spacing)
;;     (SLASH      "/" spacing)
;;     (AND        "&" spacing)
;;     (NOT        "!" spacing)
;;     (QUESTION   "?" spacing)
;;     (STAR       "*" spacing)
;;     (PLUS       "+" spacing)
;;     (OPEN       "(" spacing)
;;     (CLOSE      ")" spacing)
;;     (DOT        "." spacing)
;;
;;     (spacing     (* (choose space comment)))
;;     (comment     "#" (* [(not end-of-line) .]) end-of-line)
;;     (space       (choose " " "\t" end-of-line))
;;     (end-of-line (choose "\r\n" "\n" "\r"))
;;     (end-of-file (not .)))
(defmacro defsyntax-peg (name ... productions)
  (for-each prod productions
    (unless (and (cons? prod) (symbol? (car prod)))
      (panic "Invalid production: " prod)))

  (def nonterminal-names (map productions car))
  (for-each prod productions
    (assert-production-well-formed prod nonterminal-names))

  (def terminals (flat-map productions extract-terminals))

  (def src (gensym))
  `(defn ,name (,src)
    (todo "defsyntax-peg")))
