;; A parser macro for parsing with parsing expression grammars. If you're
;; trying to parse a programming language, this is the module for you.
(module std/parsing/peg
  defsyntax-peg)

(import std/parsing/peg/internals
  assert-expr-well-formed
  assert-production-well-formed
  extract-terminals
  replace-terminals)

;; Defines a parsing function. Takes the name of the function and a list of
;; productions. A parsing function returns a result. If the result is ok, it
;; contains the parse tree and the remainder of unparsed input. If the result
;; is err, it contains the parse error.
;;
;; Productions are specified as:
;;
;;   PRODUCTION ::= (PRODUCTION-NAME EXPR...)
;;   EXPR ::= . | PRODUCTION-NAME | LITERAL-STRING | (regex REGEX-STRING)
;;         |  (choose EXPR...) | [EXPR...]
;;         |  (* EXPR) | (+ EXPR) | (? EXPR)
;;         |  (and EXPR) | (not EXPR)
;;   PRODUCTION-NAME ::= any symbol other than .
;;   LITERAL-STRING ::= any string
;;   REGEX-STRING ::= the string representation of a regex
;;
;; If two or more productions share the same name, an implicit choose between
;; the different productions is inserted, with the (lexically) first one coming
;; first. There must be at least one production named root; this is where
;; parsing begins.
;;
;; For example, the PEG:
;;
;;   # Hierarchical syntax
;;   Grammar    <- Spacing Definition+ EndOfFile
;;   Definition <- Identifier LEFTARROW Expression
;;
;;   Expression <- Sequence (SLASH Sequence)*
;;   Sequence   <- Prefix*
;;   Prefix     <- (AND / NOT)? Suffix
;;   Suffix     <- Primary (QUESTION / STAR / PLUS)?
;;   Primary    <- Identifier !LEFTARROW
;;               / OPEN Expression CLOSE
;;               / Literal / Class / DOT
;;
;;   # Lexical syntax
;;   Identifier <- IdentStart IdentCont* Spacing
;;   IdentStart <- [a-zA-Z_]
;;   IdentCont  <- IdentStart / [0-9]
;;
;;   Literal    <- ['] (!['] Char)* ['] Spacing
;;               / ["] (!["] Char)* ["] Spacing
;;   Class      <- '[' (!']' Range)* ']' Spacing
;;   Range      <- Char '-' Char / Char
;;   Char       <- '\\' [nrt'"\[\]\\]
;;               / '\\' [0-2][0-7][0-7]
;;               / '\\' [0-7][0-7]?
;;               / !'\\' .
;;
;;   LEFTARROW  <- '<-' Spacing
;;   SLASH      <- '/' Spacing
;;   AND        <- '&' Spacing
;;   NOT        <- '!' Spacing
;;   QUESTION   <- '?' Spacing
;;   STAR       <- '*' Spacing
;;   PLUS       <- '+' Spacing
;;   OPEN       <- '(' Spacing
;;   CLOSE      <- ')' Spacing
;;   DOT        <- '.' Spacing
;;
;;   Spacing    <- (Space / Comment)*
;;   Comment    <- '#' (!EndOfLine .)* EndOfLine
;;   Space      <- ' ' / '\t' / EndOfLine
;;   EndOfLine  <- '\r\n' / '\n' / '\r'
;;   EndOfFile  <- !.
;;
;; is parsed by the parser resulting from:
;;
;;   (defsyntax-peg parse-peg
;;     ; Hierarchical syntax
;;     (root       spacing (+ definition) end-of-file)
;;     (definition identifier LEFT-ARROW expression)
;;
;;     (expression sequence (* [SLASH sequence]))
;;     (sequence   (* prefix))
;;     (prefix     (? (choose AND NOT)) suffix)
;;     (suffix     primary (? (choose QUESTION STAR PLUS)))
;;     (primary    identifier (not LEFT-ARROW))
;;     (primary    OPEN expression CLOSE)
;;     (primary    (choose literal class dot))
;;
;;     ; Lexical syntax
;;     (identifier  ident-start (* ident-cont) spacing)
;;     (ident-start (regex "[a-zA-Z_"))
;;     (ident-cont  (choose ident-start (regex "[0-9]")))
;;
;;     (literal "'" (* [(not "'") char]) "'" spacing])
;;     (literal "\"" (* [(not "\"") char]) "\"" spacing)
;;     (class   "[" (* (not "]") range) "]" spacing)
;;     (range   char "-" char)
;;     (range   char)
;;     (char    "\\" (regex "[nrt'\"\\[\\]\\\\]"))
;;     (char    "\\" (regex "[0-2][0-7][0-7]"))
;;     (char    "\\" (regex "[0-7][0-7]?"))
;;     (char    (not "\\") .)
;;
;;     (LEFT-ARROW "<-" spacing)
;;     (SLASH      "/" spacing)
;;     (AND        "&" spacing)
;;     (NOT        "!" spacing)
;;     (QUESTION   "?" spacing)
;;     (STAR       "*" spacing)
;;     (PLUS       "+" spacing)
;;     (OPEN       "(" spacing)
;;     (CLOSE      ")" spacing)
;;     (DOT        "." spacing)
;;
;;     (spacing     (* (choose space comment)))
;;     (comment     "#" (* [(not end-of-line) .]) end-of-line)
;;     (space       (choose " " "\t" end-of-line))
;;     (end-of-line (choose "\r\n" "\n" "\r"))
;;     (end-of-file (not .)))
(defmacro defsyntax-peg (name ... productions)
  (defn prod-fn-name (n)
    (symbol<-string (concat-strings "parse-production-" (string<-symbol n))))
  (defn term-fn-name (n)
    (symbol<-string (concat-strings "parse-terminal-" (string<-symbol n))))
  (defn term-index-name (n)
    (symbol<-string (concat-strings "terminal-" (show n))))

  (for-each prod productions
    (unless (and (cons? prod) (symbol? (car prod)))
      (panic "Invalid production: " prod)))
  (unless (any productions \(eq (car $) 'root))
    (panic "No root production"))

  (def nonterminal-names (map productions car))
  (for-each prod productions
    (assert-production-well-formed prod nonterminal-names))

  (def terminals (unique (flat-map productions extract-terminals)))
  (def terminal-names (build-list (length terminals) \(gensym)))

  (defn convert-terminal (tmp)
    (def name (term-index-name (car tmp)))
    (def terminal (cdr tmp))
    (case (car terminal)
      'regex
        (list 'regex (cdr terminal) name)
      'string
        (list 'simple (cdr terminal) name)
        (panic "Invalid terminal")))
  (def lexer-terminals (map (enumerate terminals) convert-terminal))
  (def productions (map productions (replace-terminals (zip terminals terminal-names))))
  (def terminals (zip terminal-names terminals))

  (def src (gensym))
  (def lexer (gensym))

  (defn make-parser-frag (expr)
    (cond
      (eq expr '.)
        (todo expr)
      (symbol? expr)
        (todo expr)
      (shl? expr 'choose)
        (todo expr)
      (shl? expr 'terminal)
        (todo expr)
      (vector? expr)
        (todo expr)
      (or (shl? expr '*)
          (shl? expr '+)
          (shl? expr '?)
          (shl? expr 'and)
          (shl? expr 'not))
        (todo expr)
      else
        (panic "Invalid expr: " expr)))
  (defn make-prod-parser-func (prod)
    (def name (prod-fn-name (car prod)))
    (def expr (vector<-list (cdr prod)))
    `(,name (,src) ,(make-parser-frag expr)))
  (defn make-term-parser-func (term)
    (def name (term-fn-name (car term)))
    `(,name (,src) (todo 'term ',term)))

  `(def ,name (progn
    (def ,lexer (must (build-lexer ',lexer-terminals)))
    ,@(map terminals \(cons 'defn (make-term-parser-func $)))
    (defnrec ,@(map productions make-prod-parser-func))
    (defn ,name (,src)
      (,(prod-fn-name 'root) ,src))
    ,name)))
