;; TODO THIS SHOULD BE GENERATED.
(module std/prelude
  *
  +
  -
  ->
  ->>
  .
  /
  /=
  <
  <-
  <=
  =
  >
  >=
  0?
  0-
  1+
  1-
  aif
  all
  and
  any-shl?
  any
  append
  apply
  assert
  assert-eq
  build-list
  build-vector
  caaaar
  caaadr
  caaar
  caadar
  caaddr
  caadr
  caar
  cadaar
  cadadr
  cadar
  caddar
  cadddr
  caddr
  cadr
  car
  case
  cdaaar
  cdaadr
  cdaar
  cdadar
  cdaddr
  cdadr
  cdar
  cddaar
  cddadr
  cddar
  cdddar
  cddddr
  cdddr
  cddr
  cdr
  compile-time-eval
  concat
  concat-strings
  cond
  contains?
  cons
  cons?
  debug-trace
  defclass
  defcurried
  defmethod
  display
  displayln
  each
  else
  empty?
  enumerate
  eq
  err
  err?
  exit
  false
  filter
  flat-map
  foldl
  foldr
  for-each
  function?
  gensym
  geq
  get
  greater
  group-by
  head
  id
  init
  last
  length
  leq
  less
  let
  let1
  letrec
  list
  list?
  list<-vector
  lookup
  lookup-by
  make-vector
  map
  match
  mod
  must
  neq
  nil
  nil?
  not
  nth
  ok
  ok?
  or
  or-default
  panic
  print
  println
  put
  quasiquote
  result.ap ; TODO This should probably be removed once get/put work.
  result.bind ; TODO This should probably be removed once get/put work.
  result.fmap ; TODO This should probably be removed once get/put work.
  result.pure ; TODO This should probably be removed once get/put work.
  reverse
  shl?
  show
  skip
  sort
  sort-by
  string?
  string<-symbol
  string.explode
  string.ord
  string.slice
  symbol?
  symbol<-string
  tail
  take
  todo
  true
  uniq
  unique
  unless
  vector?
  vector<-list
  when
  zip)

(import std/internal/prelude/assert
  assert
  assert-eq)
(import std/internal/prelude/constants
  else
  false
  nil
  true)
(import std/internal/prelude/format
  show)
(import std/internal/prelude/fp
  .
  all
  any
  defcurried
  enumerate
  filter
  flat-map
  foldl
  foldr
  each
  group-by
  lookup
  lookup-by
  map
  skip
  sort
  sort-by
  take
  uniq
  unique
  zip)
(import std/internal/prelude/logic
  and
  or)
(import std/internal/prelude/patterns/match
  match)
(import std/internal/prelude/math
  *
  +
  -
  /
  /=
  <
  <=
  >
  >=
  0?
  0-
  1+
  1-
  mod)
(import std/internal/prelude/objects
  defclass
  defmethod)
(import std/internal/prelude/objects/common-methods
  empty?
  head
  tail)
(import std/internal/prelude/print
  display
  displayln
  print
  println)
(import std/internal/prelude/quasiquote
  quasiquote)
(import std/internal/prelude/result
  err
  err?
  must
  ok
  ok?
  result.ap
  result.bind
  result.fmap
  result.pure)
(import std/internal/prelude/store
  get
  put)
(import std/internal/prelude/strings
  string.explode)
(import std/internal/prelude/util
  any-shl?
  build-list
  caar
  cadr
  cdar
  cddr
  caaar
  caadr
  cadar
  caddr
  cdaar
  cdadr
  cddar
  cdddr
  caaaar
  caaadr
  caadar
  caaddr
  cadaar
  cadadr
  caddar
  cadddr
  cdaaar
  cdaadr
  cdadar
  cdaddr
  cddaar
  cddadr
  cdddar
  cddddr
  exit
  geq
  greater
  leq
  less
  make-vector
  or-default
  reverse
  shl?
  split-at)
(import std/internal/prelude/util/macros
  ->
  ->>
  <-
  aif
  case
  compile-time-eval
  cond
  debug-trace
  for-each
  let
  let1
  letrec
  todo
  unless
  when)
(import std/internal/prelude/util/pseudoprims
  append
  concat
  contains?
  id
  init
  last
  length
  list
  list?
  neq
  not
  nth)
(import std/internal/primitives
  =
  apply
  build-vector
  car
  cdr
  concat-strings
  cons
  cons?
  eq
  function?
  gensym
  list<-vector
  nil?
  panic
  string?
  string<-symbol
  string.ord
  string.slice
  symbol?
  symbol<-string
  vector?
  vector<-list)
